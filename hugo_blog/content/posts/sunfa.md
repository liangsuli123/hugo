---
title: "算法"
date: 2016-05-12T14:26:00+08:00
draft: false
tags: ["基础"]
slug: "Suanfa"
---



```
	冒泡排序
	冒泡排序(Bubble Sort)也是一种简单直观的排序算法. 它重复地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来.走访数列的工作是重复地进行直到没有再需要交换,也就是说该数列已经排序完成.这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端.
	作为最简单的排序算法之一,冒泡排序给我的感觉就像Abandon在单词书里出现的感觉一样,每次都在第一页第一位,所以最熟悉.冒泡排序还有一种优化算法,就是立一个flag,当在一趟序列遍历中元素没有发生交换,则证明该序列已经有序.但这种改进对于提升性能来说并没有什么太大作用.
	1.     算法步骤
		1.     比较相邻的元素,如果第一个比第二个大,就交换他们两个
		2.     对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对.这步做完后,最后元素会是最大的数
		3.     针对所有的元素重复以上的步骤,除了最后一个
		4.     持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较
	2.     什么时候最快
    当输入的数据已经是正序时,最快
    3.     什么时候最慢
    当输入的数据是反序时
    4.     Python代码实现
	 def bubbleSort(nums):
	    for i in range(len(nums)-1):    # 这个循环负责设置冒泡排序进行的次数
	        for j in range(len(nums)-i-1):  # ｊ为列表下标
	            if nums[j] > nums[j+1]:
	                nums[j], nums[j+1] = nums[j+1], nums[j]
	    return nums
	
	
    
    选择排序:
	选择排序是一种简单直观的排序算法,无论什么数据进去都是O(n2)的时间复杂度.所以用到它的时候,数据规模越小越好.唯一的好处可能就是不占用额外的内存空间了吧.
	1. 算法步骤
	1.  首先在未排序序列中找到最小(大)元素,存放到排序序列的起始位置
	2.  再从剩余未排序元素中继续寻找最小(大)元素,然后放到已排序序列的末尾
	3.  重复第二步,直到所有元素均排序完毕
	2. python代码实现
	def choise(nums):
	    for i in range(len(nums)-1):
	        num = i
	        for j in range(i+1, len(nums)):
	            if nums[i] > nums[j]:
	                nums[i], nums[j] = nums[j], nums[i]
	    return nums
	 
	
    
    插入排序
	插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴,但它的原理应该是最容易理解的了,因为只要打过扑克牌的人都应该能够秒懂.插入排序是一种最简单直观的排序算法,它的工作原理是通过构建有序序列,对于未排序数据,在已排序序列中从后向前扫描,找到相应位置并插入.
	插入排序和冒泡排序一样,也有一种优化算法,叫做折半插入.
	 
	1.     算法步骤
		1.     将第一待排序序列第一个元素看做一个有序序列,将第二个元素到最后一个元素当做未排序序列
		2.     从头到尾依次扫描未排序序列,将扫描到的每个元素插入有序序列的适当位置.(如果待插入的元素与有序序列中的某个元素相等,则将待插入元素插入到相等元素的后面)
	 
	
    
    def InsertSort(myList):
	    # 获取列表长度
	    length = len(myList)
	    for i in range(1, length):
	        # 设置当前值前一个元素的标识
	        j = i - 1
	        # 如果当前值小于前一个元素,则将当前值作为一个临时变量存储,将前一个元素后移一位
	        if(myList[i] < myList[j]):
	            temp = myList[i]
	            myList[i] = myList[j]
	            # 继续往前寻找,如果有比临时变量大的数字,则后移一位,直到找到比临时变量小的元素或者达到列表第一个元素
	            j = j-1
	            while j >= 0 and myList[j] > temp:
	                myList[j+1] = myList[j]
	                j = j-1
	            # 将临时变量赋值给合适位置
	            myList[j+1] = temp
	 
	
    
    希尔排序
	希尔排序,也称递减增量排序算法,是插入排序的一种更高效的改进版本.但希尔排序是非稳定排序算法.
	希尔排序是基于插入排序的以下两点性质而提出改进方法的:
		·       插入排序在对几乎已经排好序的数据操作时,效率高,即可以达到线性排序的效率
		·       但插入排序一般来说是低效的,因为插入排序每次只能将数据移动一位
	希尔排序的基本思想是: 先将整个待排序的记录序列分割成若干子序列分别进行直接插入排序,待整个序列中的记录”基本有序”时,再对全体记录进行依次直接插入排序
	 
	1.     算法步骤
		1.     选择一个增量序列 t1,t2,……,tk  ,其中 ti>tj,tk=1
		2.     按增量序列个数k,对序列进行k趟排序
		3.     每趟排序,根据对应的增量ti,将待排序列分割成若干长度为m的子序列,分别对各字表进行直接插入排序.仅增量因子为1时,整个序列作为一个表来处理,表长度即为整个序列的长度.
	2.     代码实现
	 
	def shell_sort(li):
	    n = len(li)  # li列表中有n个数 下标从0到n-1
	    gep = n//2  # 设置初始步长进行分组
	    #当步长大于等于1的时候 一直进行分组的插入排序
	    while gep >= 1:
	        # 从gep的元素往后 一个一个元素对前面所有组跟自己处于相同位置的数进行插入排序
	        for j in range(gep, n):
	            i = j  # 标记下当前j的位置给i
	            # 这层循环是为了回跳i所在位置，
	            # 当一个新元素对前组同位置元素交换后，当前元素还需要跟再往前组的同位置元素比较决定是不是要交换
	            # i - gep 能看我当前是不是第一组位置，如果是第一组位置，我前面没有组了，就不循环了，
	            # 如果我是第三组，我会跳到前二组再跟第一组的相同位置元素进行比较
	            while i - gep >= 0:
	                #如果当前数比前一组同位置数小，就交换数值
	                if li[i] < li[i-gep]:
	                    li[i], li[i-gep] = li[i-gep], li[i]
	                    #如果我和前一组同位置元素交换了，我需要继续与再往前一组同位置元素比较是否需要交换
	                    #这个操作是把我当前位置回跳到上一组的同位置
	                    i -= gep
	                #如果没有发生数据交换，说明前面的不用再比较了，前面的一定都比我当前数小，跳出回跳位置的循环
	                else:
	                    break
	        #修改步长 缩小步长
	        gep //= 2
	 
	if __name__ == '__main__':
	    li = [5, 4, 3, 2, 1]
	    shell_sort(li)
	    print(li)
	 
	 
	
    
    
    归并排序
	归并排序是建立在归并操作上的一种有效的排序算法.该算法是采用分治法的一个非常典型的应用.
	作为一种典型的分而治之思想的算法应用,归并排序的实现由两种方法:
		·       自上而下的递归(所有递归的方法都可以用迭代重写,所以就有了第2种方法)
		·       自下而上的迭代
	和选择排序一样,归并排序的性能不受输入数据的影响,但表现比选择排序好的多,因为始终都是O(nlogn)的时间复杂度.代价是需要额外的内存空间
	1.     算法步骤
		1.     申请空间,使其大小为两个已经排序序列之和,该空间用来存放合并后的序列
		2.     设定两个指针,最初位置分别为两个已经排序序列的起始位置
		3.     比较两个指针所指向的元素,选择相对小的元素放入到合并空间,并移动指针到下一位置
		4.     重复步骤3直到某一指针达到序列尾
		5.     将另一序列剩下的所有元素直接复制到合并序列尾
	 
	2.     代码实现
	def merge_sort(li):
	    # 不断递归调用自己一直到拆分成成单个元素的时候就返回这个元素，不再拆分了
	    if len(li) == 1:
	        return li
	 
	    # 取拆分的中间位置
	    mid = len(li) // 2
	    # 拆分过后左右两侧子串
	    left = li[:mid]
	    right = li[mid:]
	 
	    # 对拆分过后的左右再拆分 一直到只有一个元素为止
	    # 最后一次递归时候ll和lr都会接到一个元素的列表
	    # 最后一次递归之前的ll和rl会接收到排好序的子序列
	    ll = merge_sort(left)
	    rl = merge_sort(right)
	 
	    # 我们对返回的两个拆分结果进行排序后合并再返回正确顺序的子列表
	    # 这里我们调用拎一个函数帮助我们按顺序合并ll和lr
	    return merge(ll, rl)
	 
	# 这里接收两个列表
	 
	def merge(left, right):
	    # 从两个有顺序的列表里边依次取数据比较后放入result
	    # 每次我们分别拿出两个列表中最小的数比较，把较小的放入result
	    result = []
	    while len(left) > 0 and len(right) > 0:
	        # 为了保持稳定性，当遇到相等的时候优先把左侧的数放进结果列表，因为left本来也是大数列中比较靠左的
	        if left[0] <= right[0]:
	            result.append(left.pop(0))
	        else:
	            result.append(right.pop(0))
	    # while循环出来之后 说明其中一个数组没有数据了，我们把另一个数组添加到结果数组后面
	    result += left
	    result += right
	    return result
	 
	if __name__ == '__main__':
	    li = [123, 53, 21, 32, 41, 1]
	    li2 = merge_sort(li)
	    print(li2)
	
	
    
    
    快速排序
	快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。
	快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。
	快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。
	快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：
	快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。
	1. 算法步骤
	 
1.从数列中挑出一个元素，称为 “基准”（pivot）;
2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
 
	递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
	 
	 
	 
	def QuickSort(myList, start, end):
	    #判断low是否小于high,如果为false,直接返回
	    if start < end:
	        i, j = start, end
	        #设置基准数
	        base = myList[i]
	 
	        while i < j:
	            #如果列表后边的数,比基准数大或相等,则前移一位直到有比基准数小的数出现
	            while (i < j) and (myList[j] >= base):
	                j = j - 1
	 
	            #如找到,则把第j个元素赋值给第个元素i,此时表中i,j个元素相等
	            myList[i] = myList[j]
	 
	            #同样的方式比较前半区
	            while (i < j) and (myList[i] <= base):
	                i = i + 1
	            myList[j] = myList[i]
	        #做完第一轮比较之后,列表被分成了两个半区,并且i=j,需要将这个数设置回base
	        myList[i] = base
	 
	        #递归前后半区
	        QuickSort(myList, start, i - 1)
	        QuickSort(myList, j + 1, end)
	    return myList
	 
	myList = [49, 38, 65, 97, 76, 13, 27, 49]
	print("Quick Sort: ")
	QuickSort(myList, 0, len(myList)-1)
	print(myList)
	 
	 
	
    
    堆排序
	堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
	大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
	小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；
	堆排序的平均时间复杂度为 Ο(nlogn)。
	1. 算法步骤
	1.创建一个堆 H[0……n-1]；
	2.把堆首（最大值）和堆尾互换；
	3.把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；
	4.重复步骤 2，直到堆的尺寸为 1。
	 
	Python代码实现
	def sift(data, low, high):
	    i = low      # 父节点
	    j = 2 * i + 1   # 左子节点
	    tmp = data[i]   # 父节点值
	    while j <= high:    # 子节点在节点中
	        if j < high and data[j] > data[j + 1]:  # 有右子节点且右节点比父节点值大
	            j += 1
	        if tmp > data[j]:
	            data[i] = data[j]   # 将父节点替换成新的子节点的值
	            i = j   # 变成新的父节点
	            j = 2 * i + 1   # 新的子节点
	        else:
	            break
	    data[i] = tmp   # 将替换的父节点值赋给最终的父节点
	 
	def heap_sort(data):
	    n = len(data)
	    # 创建堆
	    for i in range(n//2-1, -1, -1):
	        sift(data, i, n-1)
	 
	    # 挨个出数
	    for i in range(n-1, -1, -1):    # 从大到小
	        data[0], data[i] = data[i], data[0]     # 将最后一个值与父节点交互位置
	        sift(data, 0, i-1)
	 
	li = list(range(10))
	random.shuffle(li)
	print(li)
	heap_sort(li)
	print(li)
	 
	 
	
    
    计数排序
	 
	计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数
	 
	def sort(l):
	    n = len(l)
	    res = [None] * n
	    # 首次循环遍历, 每个列表的数都统计
	    for i in range(n):
	        # p 表示 a[i] 大于列表其他数 的次数
	        p = 0
	        # q 表示 等于 a[i] 的次数
	        q = 0
	        # 二次循环遍历, 列表中的每个数都和首次循环的数比较
	        for j in range(n):
	            if l[i] > l[j]:
	                p += 1
	            elif l[i] == l[j]:
	                q += 1
	        for k in range(p, p+q):  # q表示 相等的次数,就表示, 从 P 开始索引后, 连续 q 次,都是同样的 数
	            res[k] = l[i]
	    return res
	 
	print(sort([123,421,23,41,235,1])) 
	 
	
    
    
    桶排序
	 
	桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：
	在额外空间充足的情况下，尽量增大桶的数量
	使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中
	同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。
	1. 什么时候最快
	当输入的数据可以均匀的分配到每一个桶中。
	2. 什么时候最慢
	当输入的数据被分配到了同一个桶中。
	第一种方式
	def bucksort(A):
	 
	    bucks = dict()      # 定义一个桶变量，类型为字典
	    for i in A:
	        bucks.setdefault(i, [])  # 每个桶默认为空列表
	        bucks[i].append(i)      # 往对应的桶中添加对应相同元素
	    print(bucks)
	    A_sort = []
	    for i in range(min(A), max(A)+1):
	        if i in bucks:                  # 检查是否存在对应数字的桶
	            A_sort.extend(bucks[i])     # 合并桶中数据
	    return A_sort
	 
	A = [2, 3, 5, 4, 6, 7, 3, 3, 0, 8, 5]
	a = bucksort(A)
	print(a)
	 



```







    


